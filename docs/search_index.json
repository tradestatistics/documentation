[
["index.html", "Open Trade Statistics Documentation A simple documentation", " Open Trade Statistics Documentation Pachá (Mauricio Vargas Sepúlveda) 2018-10-21 A simple documentation This documentation is an attempt to try to explain how to use the scripts that generate the data that powers Open Trade Statistics. We made all the scripts available on my GitHub profile. "],
["data-sources.html", "Section 1 Data Sources", " Section 1 Data Sources All of the product data shown on the OTS site is classified using either SITC (Standard International Trade Classification) or HS (Harmonized System), the raw data was obtained from UN COMTRADE and its under their authorization that we share claned versions of the original raw datasets. "],
["data-availability.html", "Section 2 Data Availability 2.1 Yearly data", " Section 2 Data Availability We covered different periods of years according to the data availability. 2.1 Yearly data Classification Availability HS rev 1992 1992 – 2016 HS rev 1996 1996 – 2016 HS rev 2002 2002 – 2016 HS rev 2007 2007 – 2016 SITC rev 1 1962 – 2016 SITC rev 2 1976 – 2016 "],
["data-processing.html", "Section 3 Data Processing 3.1 Tidy Data 3.2 Filling gaps in our data 3.3 Countries not included in rankings and indicators 3.4 GitHub repositories 3.5 Software information 3.6 Hardware information 3.7 Reproducibility notes 3.8 Coding style and performant code 3.9 Materials of interest", " Section 3 Data Processing 3.1 Tidy Data We followed Tidy Data principles exposed in [1] and [2]. Those principles are closely tied to those of relational databases and Codd’s relational algebra. Figure 3.1: Data pipeline 3.2 Filling gaps in our data We use mirrored flows to cover gaps in raw data. Some countries report zero exports for some products, but we can inspect what their trade partners reported. If country A reported zero exports (imports) of product B to (from) country C, then we searched what country C reported of imports (exports) of product B from (to) country A. Exports are reported FOB (free on board) while imports are reported CIF (cost, insurance and freight). When country A sends products to country C that will be registered with a larger value when it arrives to destination because the importer is including cost, insurance and freight that was not registered before shipping. There are different approaches to solve this difficulty, and in particular [3], [4] and [5] discuss this in detail and propose that an 8% CIF/FOB ratio is suitable to discount costs and compare imports and exports. There are some noble and remarkable approaches such as gravitational models. As, to our knowledge at the moment, there is no literature reporting the estimation of a gravity equation for this purpose that returns a satisfactory fitting. Let \\(x_{c,c&#39;,p}\\) represent the exports of country \\(c\\) to country \\(c&#39;\\) in product \\(p\\) and \\(m_{c&#39;,c,p}\\) the imports of country \\(c&#39;\\) from country \\(c\\). Under this notation I defined corrected flows as: \\[\\hat{x}_{c,c&#39;,p} = \\max\\left\\{x_{c,c&#39;,p}, \\frac{m_{c&#39;,c,p}}{1.08}\\right\\}\\] \\[\\hat{m}_{c,c&#39;,p} = \\max\\left\\{x_{c&#39;,c,p}, \\frac{m_{c,c&#39;,p}}{1.08}\\right\\}\\] After symmetrization all observations are rounded to zero decimals. 3.3 Countries not included in rankings and indicators The curated data includes all the countries available from UN Comtrade data. However, RCA based calculations such as ECI, PCI, Proximity and Density explained in Chapter 4 consider 128 countries that account for 99% of world trade, 97% of the world’s total GDP and 95% of the world’s population according to [6]. I considered simultaneously: Countries with population greater or equal to 1.2 million Countries whose traded value is greater or equal than 1 billion Figure 3.2: Schematic of the procedure used to determine the countries that were included in the Atlas 3.4 GitHub repositories Getting and cleaning data from UN COMTRADE (OTS Yearly Data) Scraping data in The Atlas of Economic Complexity (OTS Atlas Data) Product and country codes (OTS Observatory Codes) Product and country codes (OTS Comtrade Codes) R packages library for reproducibility (OTS Packrat Library) 3.5 Software information We used R 3.4.3 and RStudio Desktop 1.1 on Ubuntu Desktop 18.04. We built R from binaries in order to obtain a setup linked with multi-threaded numeric libraries. Our build is linked to OpenBLAS which we used over alternatives such as Intel MKL, BLAS or ATLAS that can also be used. If you use Windows the scripts will only use a single core because we used a parallelization that depends on fork system call that is only supported on Unix systems. You can always run the scripts on Windows and the only difference will be that it will use less RAM and it will be slower to compute. Also, before running the scripts on Windows verify that you installed GNU Utilities beforehand. One easy option is to install Chocolatey first and then install the GNU Utilities by running choco install unxutils Cmd or Power Shell as administrator. 3.6 Hardware information All the data processing was done by using a Lenovo Thinkpad L380 that features an Intel i5-8250U 1.60 GHz processor and 32 GB (two DDR4 cards of sixteen gigabytes each). The functions are executed using parallelization on four cores because empirically I detected and overhead due to data communication with the cores when using more cores. Please notice that running our scripts with parallelization demands more RAM than the amount you can find on an average laptop. You can always disable parallelization in the scripts or reduce the default number of cores. 3.7 Reproducibility notes To guarantee reproducibility we provide Packrat snapshot and bundles. This prevents changes in syntax, functions or dependencies. Our R installation is isolated from apt-get to avoid any accidental updates that can alter the data pipeline and/or the output. The projects are related to each other. In order to avoid multiple copies of files some projects read files from other projects. For example, OTS Yearly Datasets input is the output of OTS Atlas Data. The only reproducibility flaw of this project lies in data downloading. Obtaining raw datasets from UN COMTRADE demands an API key that can only be obtained with institutional access that is limited to some universities and institutes. 3.8 Coding style and performant code We used the Tidyverse Style Guide. As cornerstone references for performant code we followed [7] and [8]. Some matrix operations are written in Rcpp to take advantage of C++ speed. To take full advantage of hardware and numerical libraries I am using sparse matrices as it is explained in [9]. 3.9 Materials of interest Product space layouts (Pacha’s Product Space) References "],
["the-mathematics-of-economic-complexity.html", "Section 4 The Mathematics of Economic Complexity 4.1 Revealed Comparative Advantage (RCA) 4.2 Smooth Revealed Comparative Advantage (SRCA) 4.3 Diversity and Ubiquity 4.4 Reflections Method 4.5 Economic Complexity Index (ECI) 4.6 Product Complexity Index (PCI) 4.7 Product Proximity 4.8 Country Proximity 4.9 Product Density 4.10 Country Density", " Section 4 The Mathematics of Economic Complexity This section is adapted from [6] but it differs at some points. In particular [10] and [11] provide useful technical details. 4.1 Revealed Comparative Advantage (RCA) When associating countries to products it is important to take into account the size of the export volume of countries and that of the world trade of products. This is because, even for the same product, I expect the volume of exports of a large country like China, to be larger than the volume of exports of a small country like Uruguay. By the same, I expect the export volume of products that represent a large fraction of world trade, such as cars or footwear, to represent a larger share of a country’s exports than products that account for a small fraction of world trade, like cotton seed oil or potato flour. To make countries and products comparable I use Balassa’s definition of Revealed Comparative Advantage (RCA). Balassa’s definition says that a country has revealed Comparative advantage in a product if it exports more than its “fair” share, that is, a share that is equal to the share of total world trade that the product represents. For example, in 2008, with exports of $42 billion, soybeans represented 0.35% of world trade. Of this total, Brazil exported nearly $11 billion, and since Brazil’s total exports for that year were $140 billion, soybeans accounted for 7.8% of Brazil’s exports. This represents around 21 times Brazil’s “fair share” of soybean exports (7.8% divided by 0.35%), so I can say that Brazil has revealed comparative advantage in soybeans. Let \\(\\hat{x}_{c,p}\\) represent the exports of country \\(c\\) in product \\(p\\), just as it was defined in 1, I can express the Revealed Comparative Advantage that country \\(c\\) has in product \\(p\\) as: \\[\\begin{equation} \\renewcommand{\\vec}[1]{\\boldsymbol{#1}} \\newcommand{\\R}{\\mathbb{R}} \\tag{4.1} RCA_{c,p} = \\frac{\\hat{x}_{c,p}}{\\sum_c \\hat{x}_{c,p}} / \\frac{\\sum_p \\hat{x}_{c,p}}{\\sum_{c}\\sum_{p} \\hat{x}_{c,p}} \\end{equation}\\] 4.2 Smooth Revealed Comparative Advantage (SRCA) I smooth changes in export volumes induced by the price fluctuation of commodities by using a modification of (4.1) in which \\(x_{c,p}\\) is averaged over the previous three years by using weights: \\[ SRCA_{c,p}^{(t)} = \\frac{\\tilde{x}_{c,p}^{(t)}}{\\sum_c \\tilde{x}_{c,p}^{(t)}} / \\frac{\\sum_p \\tilde{x}_{c,p}^{(t)}}{\\sum_{c}\\sum_{p} \\tilde{x}_{c,p}^{(t)}} \\] Where \\[ \\tilde{x}_{c,p}^{(t)} = \\frac{2\\hat{x}_{c,p}^{(t)} + \\hat{x}_{c,p}^{(t-1)} + \\hat{x}_{c,p}^{(t-2)}}{4} \\] Consider that for some years this needs to be altered. As an example, for HS2007 classification there is no data before 2007, hence for the year 2007 the SRCA is the same as RCA and for the year 2008 the \\(x_{c,p}^{(t-2)}\\) part is omitted and the denominator is changed to 3. I use this measure to construct a matrix that connects each country to the products that it makes. The entries in the matrix are 1 if country \\(c\\) exports product \\(p\\) with Revealed Comparative Advantage larger than 1, and 0 otherwise. I define this as the matrix \\(S \\in \\mathbb{R}^{C\\times P}\\) with entries: \\[\\begin{equation} \\tag{4.2} s_{c,p} = \\begin{cases}1 &amp; \\text{ if } SRCA_{c,p}^{(t)} \\geq 1\\cr 0 &amp; \\text{ otherwise} \\end{cases} \\end{equation}\\] \\(S\\) is the matrix summarizing which country makes what, and is used to construct the product space and our measures of economic complexity for countries and products. In order to compute some of the equations exposed here I had to reduce \\(S\\) by removing cols and rows where each entry is zero. For some years the number of countries \\(C\\) can be less than 128 as it was exposed in 3. The number of products \\(P\\) for a given year can also experience a small decrease. It is also important that beyond computability some products were intensively exported in past decades but then their were replaced by other products. Think of floppy disks exports or saltpeter exports. 4.3 Diversity and Ubiquity With \\(S\\) defined as in the previous sections, I can measure Diversity and Ubiquity simply by summing over the rows or columns of that matrix. I define Diversity as: \\[k_{c}^{(0)} = \\sum_p s_{c,p}\\] And Ubiquity as: \\[k_{p}^{(0)} = \\sum_c s_{c,p}\\] 4.4 Reflections Method To generate a more accurate measure of the number of capabilities available in a country, or required by a product, I need to correct the information that diversity and ubiquity carry by using each one to correct the other. For countries, this is to calculate the average ubiquity of the products that it exports, the average diversity of the countries that make those products and so forth. For products, this is to calculate the average diversity of the countries that make them and the average ubiquity of the other products that these countries make. This can be expressed by the recursion: \\[\\begin{equation} \\tag{4.3} k_{c}^{(n)} = \\frac{1}{k_{c}^{(0)}} \\sum_p s_{c,p} k_{p}^{(n-1)} \\end{equation}\\] \\[\\begin{equation} \\tag{4.4} k_{p}^{(n)} = \\frac{1}{k_{p}^{(0)}} \\sum_c s_{c,p} k_{c}^{(n-1)} \\end{equation}\\] Then I insert (4.4) into (4.3) to obtain: \\[\\begin{equation} \\tag{4.5} k_{c}^{(n)} = \\sum_c \\left[\\frac{1}{k_{c}^{(0)}} \\sum_p s_{c,p} \\frac{1}{k_{p}^{(0)}} s_{c,p} \\right] k_{c}^{(n-2)} \\end{equation}\\] The equation above can be conveniently written as a matrix equation (this formulation takes some ideas from [10] and [11]): \\[\\begin{equation} \\tag{4.6} \\vec{k}^{(n)} = \\hat{S}\\vec{k}^{(n-2)} \\end{equation}\\] Where \\[\\begin{equation} \\tag{4.7} \\hat{s}_{c,c&#39;} = \\frac{1}{k_{c}^{(0)}} \\sum_p s_{c,p} \\frac{1}{k_{p}^{(0)}} s_{c,p} \\end{equation}\\] In a similar way I can define \\(\\tilde{S}\\) with entries: \\[\\begin{equation} \\tag{4.8} \\tilde{s}_{p,p&#39;} = \\frac{1}{k_{p}^{(0)}} \\sum_c s_{c,p} \\frac{1}{k_{c}^{(0)}} s_{c,p} \\end{equation}\\] I note (4.6) is satisfied when \\(k_{c}^{(n)} = k_{c}^{(n-2)} = 1\\). This is the eigenvector of \\(\\tilde{S}\\) which is associated with its largest eigenvalue. Since this eigenvector is a vector of ones, it is not informative. I look, instead, for the eigenvector associated with the second largest eigenvalue. This is the eigenvector that captures the largest amount of variance in the system and is our measure of Economic Complexity. In particular, the interpretation of the scores changes when considering odd or even iteration order \\(n\\), high-order iterations are difficult to interpret, and the process asymptotically converges to a trivial fixed point. For the analysis I used \\(n=19\\) to compute \\(k_c\\) and \\(n=20\\) to compute \\(k_p\\). 4.5 Economic Complexity Index (ECI) From the Reflections Method, I define the Economic Complexity Index (ECI) as: \\[\\begin{equation} \\tag{4.9} ECI_c = \\frac{v_c - \\mu_{v}}{\\sigma_{v}} \\end{equation}\\] Where \\(\\vec{v}\\) is a vector whose coordinates are given by \\(k_{c}^{(19)}\\) where \\(p \\in 1,\\ldots,C\\) \\(\\mu_v = \\sum_c v_c / C\\) (mean of \\(\\vec{v}\\)) \\(\\sigma_v = \\sqrt{\\sum_c (v_c - \\mu_v)^2 / (C - 1)}\\) (standard deviation of \\(\\vec{v}\\)) 4.6 Product Complexity Index (PCI) Similar to the Economic Complexity Index (ECI), I define a Product Complexity Index (PCI). Because of the symmetry of the problem, this can be done simply by exchanging the index of countries \\(c\\) with that for products \\(p\\) in the definitions above. I define PCI as: \\[\\begin{equation} \\tag{4.10} PCI_p = \\frac{w_p - \\mu_{w}}{\\sigma_{w}} \\end{equation}\\] Where \\(\\vec{w}\\) is a vector whose coordinates are given by \\(k_{p}^{(20)}\\) where \\(p \\in 1,\\ldots,P\\) \\(\\mu_w = \\sum_p w_p / P\\) (mean of \\(\\vec{w}\\)) \\(\\sigma_w = \\sqrt{\\sum_p (w_p - \\mu_w)^2 / (P - 1)}\\) (standard deviation of \\(\\vec{w}\\)) 4.7 Product Proximity To make products you need chunks of embedded knowledge which I call capabilities. The capabilities needed to produce one good may or may not be useful in the production of other goods. Since I do not observe capabilities directly, I create a measure that infers the similarity between the capabilities required by a pair of goods by looking at the probability that they are coexported. To quantify this similarity I assume that if two goods share most of the requisite capabilities, the countries that export one will also export the other. Our measure is based on the conditional probability that a country that exports product \\(p\\) will also export product \\(p&#39;\\) (see figure). Since conditional probabilities are not symmetric I take the minimum of the probability of exporting product \\(p\\), given \\(p&#39;\\) and the reverse, to make the measure symmetric and more stringent. As an example, assume that in the year 2017, 20 countries exported wine, 25 exported grapes and 15 exported both, all with \\(RCA &gt; 1\\). Then, the product proximity between wines and grapes is 15/25. For a pair of goods \\(p\\) and \\(p&#39;\\) I define Product Proximity \\(\\Phi \\in \\mathbb{R}^{P\\times P}\\) as: \\[ \\Phi = (S^t S) \\odot U \\] Where \\(\\odot\\) denotes element-wise multiplication and \\[u_{p,p&#39;} = 1 / \\max(k_{p}^{(0)}, k_{p&#39;}^{(0)})\\] In other terms, each entry of \\(\\Phi\\) corresponds to: \\[ \\phi_{p,p&#39;} = \\frac{\\sum_c s_{c,p} s_{c,p&#39;}}{\\max(k_{p}^{(0)}, k_{p&#39;}^{(0)})} \\] Figure 3.1: An illustrative example for the product proximity measure 4.8 Country Proximity Similar to 4.8, I define Country Proximity \\(\\Lambda \\in \\mathbb{R}^{C\\times C}\\) as: \\[ \\Lambda = (SS^t) \\odot D \\] Where \\[d_{c,c&#39;} = 1 / \\max(k_{c}^{(0)}, k_{c&#39;}^{(0)})\\] In other terms, each entry of \\(\\Lambda\\) corresponds to: \\[ \\lambda_{c,c&#39;} = \\frac{\\sum_p s_{c,p} s_{c,p&#39;}}{\\max(k_{c}^{(0)}, k_{c&#39;}^{(0)})} \\] 4.9 Product Density This concept appears in [12], however the matricial formulation is not a part of the original article. Product Density is the weighted mean proximity of a new potential product \\(p\\) to a country’s current productive capability. In formal terms this is the matrix \\(\\Psi \\in \\mathbb{R}^{C\\times P}\\) defined by: \\[ \\Psi = (S\\Phi) \\oslash (\\tilde{S}\\Phi) \\] Where \\(\\tilde{s}_{c,p} = 1\\) and \\(\\oslash\\) denotes element-wise division. In other terms, each entry of \\(\\Psi\\) corresponds to: \\[ \\psi_{c,p} = \\frac{\\sum_{p} s_{c,p} \\phi_{p,p&#39;}}{\\sum_{p} \\phi_{p,p&#39;}} \\] 4.10 Country Density Similar to 4.9, I define Country Density as the matrix \\(\\Omega \\in \\mathbb{R}^{C\\times P}\\): \\[ \\Omega = (\\Lambda S) \\oslash (\\Lambda\\tilde{S}) \\] In other terms, each entry of \\(\\Omega\\) corresponds to: \\[ \\omega_{c,p} = \\frac{\\sum_{c} s_{c,p} \\phi_{c,c&#39;}}{\\sum_{c} \\phi_{c,c&#39;}} \\] References "],
["references.html", "Section 5 References", " Section 5 References "]
]
